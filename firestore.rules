rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // ============================================
    // AUTHENTICATION SUPPORT
    // ============================================
    // These rules support multiple authentication methods:
    // 1. Phone Number Authentication (OTP verification)
    // 2. Google Sign-In Authentication (OAuth)
    // 3. Email/Password Authentication
    // 
    // All methods use Firebase Authentication and provide a unified user ID (uid)
    // The isOwner() function works for all authentication providers
    
    // ============================================
    // HELPER FUNCTIONS
    // ============================================
    
    // Helper function to check if user is authenticated
    // Works for Phone, Google, and Email authentication
    function isAuthenticated() {
      return request.auth != null;
    }
    
    // Helper function to check if user owns the resource
    // Works for all authentication methods
    // Firebase Auth provides a unified uid regardless of authentication provider
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    // Helper function to check if user is a friend of the owner
    function isFriendOfOwner(ownerId) {
      return exists(/databases/$(database)/documents/users/$(ownerId)/friends/$(request.auth.uid));
    }
    
    // Helper function to check if user can read cloth
    function canReadCloth(clothData) {
      // Owner can always read
      return request.auth != null && (
        // Owner can always read
        request.auth.uid == clothData.ownerId ||
        // Public visibility - anyone authenticated can read
        (isAuthenticated() && clothData.visibility == 'public') ||
        // Friends visibility - check if user is a friend of the owner
        (isAuthenticated() && 
         clothData.visibility == 'friends' && 
         isFriendOfOwner(clothData.ownerId)) ||
        // Shared with specific users - check if user is in sharedWith array
        (isAuthenticated() && 
         clothData.sharedWith != null && 
         clothData.sharedWith is list && 
         request.auth.uid in clothData.sharedWith) ||
        // If visibility is "private" but users are friends, allow access
        // This handles cases where cloth was shared via DM but sharedWith wasn't updated
        // OR cloth was shared before sharedWith update rules were added
        (isAuthenticated() && 
         clothData.visibility == 'private' && 
         isFriendOfOwner(clothData.ownerId))
      );
    }
    
    // Helper function to validate user profile data
    function isValidUserProfile(data) {
      return (!('displayName' in data) || data.displayName is string) &&
             (!('username' in data) || (data.username is string && 
                                        data.username.size() >= 3 && 
                                        data.username.size() <= 20 &&
                                        data.username.matches('^[a-z0-9_]+$'))) &&
             (!('photoUrl' in data) || data.photoUrl is string) &&
             (!('email' in data) || data.email is string) &&
             (!('phone' in data) || data.phone is string) &&
             (!('phoneNumber' in data) || data.phoneNumber is string) &&
             (!('gender' in data) || data.gender in ['male', 'female', 'other']) &&
             (!('dateOfBirth' in data) || data.dateOfBirth is timestamp) &&
             (!('createdAt' in data) || data.createdAt is timestamp) &&
             (!('updatedAt' in data) || data.updatedAt is timestamp) &&
             (!('settings' in data) || data.settings is map);
    }
    
    // Helper function to check if username is being changed (should be immutable after creation)
    function isUsernameUnchanged(data, existingData) {
      return !('username' in data) || 
             (existingData != null && 
              'username' in existingData && 
              data.username == existingData.username);
    }
    
    // Helper function to validate wardrobe data
    function isValidWardrobe(data) {
      return data.keys().hasAll(['ownerId', 'name', 'location', 'createdAt', 'updatedAt']) &&
             data.ownerId is string &&
             data.name is string &&
             data.name.size() > 0 &&
             data.location is string &&
             data.location.size() > 0 &&
             data.createdAt is timestamp &&
             data.updatedAt is timestamp &&
             (!('totalItems' in data) || data.totalItems is int);
    }
    
    // Helper function to validate cloth data
    function isValidCloth(data) {
      return data.keys().hasAll(['ownerId', 'wardrobeId', 'imageUrl', 'season', 'placement', 'clothType', 'category', 'occasions', 'colorTags', 'createdAt', 'updatedAt']) &&
             data.ownerId is string &&
             data.wardrobeId is string &&
             data.imageUrl is string &&
             data.season is string &&
             data.placement is string &&
             data.clothType is string &&
             data.category is string &&
             data.occasions is list &&
             data.occasions.size() > 0 &&
             data.colorTags is map &&
             data.createdAt is timestamp &&
             data.updatedAt is timestamp &&
             (!('wornAt' in data) || data.wornAt is timestamp) &&
             (!('visibility' in data) || data.visibility in ['private', 'friends', 'public']) &&
             (!('sharedWith' in data) || data.sharedWith is list) &&
             (!('likesCount' in data) || data.likesCount is int) &&
             (!('commentsCount' in data) || data.commentsCount is int);
    }
    
    // Helper function to validate partial cloth update (for lastWornAt updates)
    function isValidClothPartialUpdate(data) {
      // Allow updating only lastWornAt and updatedAt fields
      // updatedAt is typically FieldValue.serverTimestamp() which is handled server-side
      // We only validate that lastWornAt is a timestamp
      return data.keys().size() == 2 &&
             'lastWornAt' in data &&
             'updatedAt' in data &&
             data.lastWornAt is timestamp;
    }
    
    // Helper function to check if update is a valid partial or full update
    function isValidClothUpdate(newData, existingData) {
      // If update includes only lastWornAt and updatedAt (partial update for wear tracking)
      // use partial validation - this allows FieldValue.serverTimestamp() for updatedAt
      // Otherwise, validate as full cloth update
      return ('lastWornAt' in newData && 
              'updatedAt' in newData &&
              newData.keys().size() == 2) 
             ? isValidClothPartialUpdate(newData)
             : isValidCloth(newData);
    }
    
    // Helper function to validate friend request data
    function isValidFriendRequest(data) {
      return data.keys().hasAll(['fromUserId', 'toUserId', 'status', 'createdAt', 'updatedAt']) &&
             data.fromUserId is string &&
             data.toUserId is string &&
             data.status in ['pending', 'accepted', 'rejected', 'canceled'] &&
             data.createdAt is timestamp &&
             data.updatedAt is timestamp;
    }
    
    // Helper function to validate chat data
    function isValidChat(data) {
      return data.keys().hasAll(['participants', 'createdAt']) &&
             data.participants is list &&
             data.participants.size() >= 2 &&
             (!('lastMessage' in data) || data.lastMessage is string) &&
             (!('lastMessageAt' in data) || data.lastMessageAt is timestamp) &&
             (!('isGroup' in data) || data.isGroup is bool) &&
             data.createdAt is timestamp;
    }
    
    // Helper function to validate message data
    function isValidMessage(data) {
      return data.keys().hasAll(['senderId', 'createdAt']) &&
             data.senderId is string &&
             (!('text' in data) || data.text is string) &&
             (!('imageUrl' in data) || data.imageUrl is string) &&
             (!('clothId' in data) || data.clothId is string) &&
             (!('seenBy' in data) || data.seenBy is list) &&
             data.createdAt is timestamp;
    }
    
    // Helper function to validate notification data
    function isValidNotification(data) {
      return data.keys().hasAll(['type', 'title', 'body', 'createdAt', 'read']) &&
             data.type in ['friend_request', 'friend_accept', 'dm_message', 'cloth_like', 'cloth_comment', 'suggestion'] &&
             data.title is string &&
             data.body is string &&
             (!('data' in data) || data.data is map) &&
             data.createdAt is timestamp &&
             data.read is bool;
    }
    
    // Helper function to validate device data
    function isValidDevice(data) {
      return data.keys().hasAll(['fcmToken', 'platform', 'isActive', 'lastActiveAt', 'createdAt']) &&
             data.fcmToken is string &&
             data.fcmToken.size() > 0 &&
             data.platform in ['android', 'ios', 'web'] &&
             data.isActive is bool &&
             data.lastActiveAt is timestamp &&
             (!('deviceName' in data) || data.deviceName is string) &&
             data.createdAt is timestamp;
    }
    
    // ============================================
    // CONFIG COLLECTION
    // ============================================
    // Tag Lists: config/tagLists
    // Read: Public (needed for app functionality before authentication)
    // Write: Admin only (configure user IDs in rules)
    match /config/{configId} {
      // Allow public read for config documents (needed for tagLists before user authentication)
      // This is safe as config data is non-sensitive app configuration
      allow read: if true;
      
      // Only admins can write (replace with your admin user IDs)
      allow write: if isAuthenticated() && 
                      (request.auth.uid == 'YOUR_ADMIN_USER_ID_1' || 
                       request.auth.uid == 'YOUR_ADMIN_USER_ID_2' ||
                       request.auth.token.admin == true);
    }
    
    // ============================================
    // USERS COLLECTION
    // ============================================
    match /users/{userId} {
      // Allow list queries (for username/email lookups during login)
      // This allows unauthenticated queries on username field for login functionality
      allow list: if true; // Allow queries for username lookups (needed before authentication)
      
      // Allow read if:
      // 1. User owns the profile (full access)
      // 2. Unauthenticated users can read username/email for login queries
      // 3. Authenticated users can read any user profile (needed for comments, friend lists, etc.)
      allow get: if isOwner(userId) || 
                     // Allow unauthenticated reads for username/email (needed for login)
                     (!isAuthenticated() && 
                      ('username' in resource.data || 'email' in resource.data)) ||
                     // Allow authenticated users to read any user profile
                     // This is needed for displaying usernames/photos in comments, friend lists, etc.
                     isAuthenticated();
      
      // Allow create if user owns the profile
      // Username must be provided and valid on creation
      allow create: if isOwner(userId) && 
                       isValidUserProfile(request.resource.data) &&
                       ('username' in request.resource.data) &&
                       request.resource.data.username is string &&
                       request.resource.data.username.size() >= 3 &&
                       request.resource.data.username.size() <= 20 &&
                       request.resource.data.username.matches('^[a-z0-9_]+$');
      
      // Allow update if user owns the profile
      // Username cannot be changed after creation (immutable)
      allow update: if isOwner(userId) && 
                       isValidUserProfile(request.resource.data) &&
                       isUsernameUnchanged(request.resource.data, resource.data);
      
      // Allow delete if user owns the profile
      allow delete: if isOwner(userId);
      
      // Friends subcollection: users/{userId}/friends/{friendId}
      match /friends/{friendId} {
        // Allow list queries for the owner (needed for loading friends list)
        allow list: if isOwner(userId);
        allow read: if isOwner(userId);
        // Allow create if:
        // 1. User owns the userId path (adding friend to their own list), OR
        // 2. User is the friendId (the other person in the friendship)
        //    This allows bidirectional friend creation when accepting a request.
        //    The application logic ensures this only happens when there's an accepted friend request.
        //    Security: Users can only add themselves (as friendId) to another user's friends list,
        //    which is safe since they're just adding their own ID.
        allow create: if (isOwner(userId) && 
                         request.resource.data.keys().hasAll(['friendId', 'createdAt']) &&
                         request.resource.data.friendId == friendId &&
                         request.resource.data.friendId is string &&
                         request.resource.data.createdAt is timestamp) ||
                        (isAuthenticated() && 
                         request.auth.uid == friendId &&
                         request.resource.data.keys().hasAll(['friendId', 'createdAt']) &&
                         request.resource.data.friendId == friendId &&
                         request.resource.data.friendId is string &&
                         request.resource.data.createdAt is timestamp);
        allow delete: if isOwner(userId);
      }
      
      // Notifications subcollection: users/{userId}/notifications/{notificationId}
      match /notifications/{notificationId} {
        allow read: if isOwner(userId);
        // Allow owner to create their own notifications
        allow create: if isOwner(userId) && isValidNotification(request.resource.data);
        // Allow authenticated users to create notifications for other users (for push notifications)
        // This is needed when sender creates notification for recipient
        // Security: Only allow specific notification types (dm_message) with valid data
        allow create: if isAuthenticated() && 
                         isValidNotification(request.resource.data) &&
                         request.resource.data.type == 'dm_message' &&
                         'data' in request.resource.data &&
                         request.resource.data.data is map &&
                         'senderId' in request.resource.data.data &&
                         request.resource.data.data.senderId == request.auth.uid;
        allow update: if isOwner(userId) && 
                         (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['read']) ||
                          isValidNotification(request.resource.data));
        allow delete: if isOwner(userId);
      }
      
      // Devices subcollection: users/{userId}/devices/{deviceId}
      match /devices/{deviceId} {
        // Allow owner to read their own devices
        allow read: if isOwner(userId);
        // Allow authenticated users to query devices for app state checks (for push notifications)
        // This allows checking if a user's app is in foreground/background
        allow list: if isAuthenticated();
        // Allow create with full device data or just isActive/lastActiveAt (for set with merge)
        allow create: if isOwner(userId) && 
                         (isValidDevice(request.resource.data) ||
                          // Allow creating with just isActive and lastActiveAt (for set with merge)
                          (('isActive' in request.resource.data && request.resource.data.isActive is bool) &&
                           ('lastActiveAt' in request.resource.data)));
        // Allow partial updates for isActive and lastActiveAt
        // Note: lastActiveAt uses FieldValue.serverTimestamp() which is a sentinel
        // Use diff() to check which fields are actually being changed
        allow update: if isOwner(userId) && 
                         // Only allow updates to isActive and/or lastActiveAt
                         (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['isActive', 'lastActiveAt']) ||
                          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['isActive']) ||
                          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['lastActiveAt'])) &&
                         // Ensure isActive is a bool if it's being updated
                         (!('isActive' in request.resource.data.diff(resource.data).affectedKeys()) ||
                          request.resource.data.isActive is bool);
        // Allow full updates that pass validation
        allow update: if isOwner(userId) && isValidDevice(request.resource.data);
        allow delete: if isOwner(userId);
      }
      
      // FCM Tokens subcollection: users/{userId}/fcmTokens/{tokenId}
      match /fcmTokens/{tokenId} {
        allow read: if isOwner(userId);
        allow create: if isOwner(userId) &&
                         request.resource.data.keys().hasAll(['token', 'userId', 'isActive', 'lastActive', 'createdAt', 'updatedAt']) &&
                         request.resource.data.token is string &&
                         request.resource.data.userId == userId;
        allow update: if isOwner(userId);
        allow delete: if isOwner(userId);
      }
      
      // Wardrobes subcollection: users/{userId}/wardrobes/{wardrobeId}
      match /wardrobes/{wardrobeId} {
        // Allow read if user owns the wardrobe or visibility allows
        // Note: Friend check for 'friends' visibility is handled at application level
        // as Firestore rules cannot use request.auth.uid in document paths
        allow read: if isOwner(userId) || 
                       (isAuthenticated() && 
                        resource.data.ownerId == userId &&
                        resource.data.visibility == 'public');
        
        allow create: if isOwner(userId) && isValidWardrobe(request.resource.data);
        allow update: if isOwner(userId) && isValidWardrobe(request.resource.data);
        allow delete: if isOwner(userId);
        
        // Clothes subcollection: users/{userId}/wardrobes/{wardrobeId}/clothes/{clothId}
        match /clothes/{clothId} {
          // Allow list queries for wardrobe owner (needed for deletion and listing)
          allow list: if isOwner(userId);
          // Also allow list for authenticated users
          // This is needed when Firestore internally uses queries for document access
          // Security: The GET rule still enforces actual read permissions via canReadCloth()
          // LIST only allows querying the collection, but individual documents still require GET permission
          allow list: if isAuthenticated();
          
          // Allow read based on cloth visibility (this is the actual security check)
          allow get: if canReadCloth(resource.data);
          
          allow create: if isOwner(userId) && isValidCloth(request.resource.data);
          
          // Allow authenticated users to update likesCount when liking/unliking
          // Simplified: If user can read the cloth, they can update likesCount
          // This allows friends and anyone with access to like/unlike clothes
          // Note: We don't check likesCount/commentsCount equality since FieldValue.increment() changes them
          allow update: if isAuthenticated() &&
                           canReadCloth(resource.data) &&
                           'updatedAt' in request.resource.data &&
                           // Ensure only critical immutable fields are unchanged (prevents tampering)
                           request.resource.data.ownerId == resource.data.ownerId &&
                           request.resource.data.wardrobeId == resource.data.wardrobeId &&
                           request.resource.data.imageUrl == resource.data.imageUrl;
          
          // Allow authenticated users to update commentsCount when adding/deleting comments
          // Simplified: If user can read the cloth, they can update commentsCount
          // This allows friends and anyone with access to comment on clothes
          // Note: We don't check likesCount/commentsCount equality since FieldValue.increment() changes them
          allow update: if isAuthenticated() &&
                           canReadCloth(resource.data) &&
                           'updatedAt' in request.resource.data &&
                           // Ensure only critical immutable fields are unchanged (prevents tampering)
                           request.resource.data.ownerId == resource.data.ownerId &&
                           request.resource.data.wardrobeId == resource.data.wardrobeId &&
                           request.resource.data.imageUrl == resource.data.imageUrl;
          
          // Allow partial update for wear tracking (wornAt + updatedAt)
          // Ensure system fields (likes/comments) are unchanged
          allow update: if isOwner(userId) && 
                           request.resource.data.likesCount == resource.data.likesCount &&
                           request.resource.data.commentsCount == resource.data.commentsCount &&
                           'updatedAt' in request.resource.data &&
                           (!('wornAt' in request.resource.data) || request.resource.data.wornAt is timestamp);
          
          // Allow owner to update sharedWith array (for sharing clothes via DM)
          // This allows updating sharedWith and updatedAt only
          allow update: if isOwner(userId) &&
                           request.resource.data.likesCount == resource.data.likesCount &&
                           request.resource.data.commentsCount == resource.data.commentsCount &&
                           'updatedAt' in request.resource.data &&
                           (!('sharedWith' in request.resource.data) || request.resource.data.sharedWith is list) &&
                           // Ensure other critical fields are unchanged
                           request.resource.data.ownerId == resource.data.ownerId &&
                           request.resource.data.wardrobeId == resource.data.wardrobeId &&
                           request.resource.data.imageUrl == resource.data.imageUrl &&
                           request.resource.data.clothType == resource.data.clothType &&
                           request.resource.data.category == resource.data.category &&
                           request.resource.data.season == resource.data.season;
          
          // Allow full cloth updates (e.g., edit cloth details)
          allow update: if isOwner(userId) &&
                           request.resource.data.likesCount == resource.data.likesCount &&
                           request.resource.data.commentsCount == resource.data.commentsCount &&
                           isValidCloth(request.resource.data);
          
          allow delete: if isOwner(userId);
          
          // Wear history subcollection: clothes/{clothId}/wearHistory/{entryId}
          match /wearHistory/{entryId} {
            allow read: if isOwner(userId);
            allow create: if isOwner(userId) &&
                             request.resource.data.keys().hasAll(['userId', 'wornAt', 'source']) &&
                             request.resource.data.userId == userId &&
                             request.resource.data.wornAt is timestamp &&
                             request.resource.data.source in ['manual', 'scheduledSuggestion'];
            allow delete: if isOwner(userId);
          }
          
          // Likes subcollection: clothes/{clothId}/likes/{likeId}
          match /likes/{likeId} {
            // Owner can do everything on their own cloths
            allow read, write: if isAuthenticated() && request.auth.uid == userId;
            
            // Allow list queries for authenticated users (needed for checking like status and getting counts)
            allow list: if isAuthenticated();
            
            // Allow GET for authenticated users (likeId is the userId, so users can check their own likes)
            // Security: CREATE rule below ensures users can only create likes if they can read the cloth
            allow get: if isAuthenticated();
            
            // Others can create likes if they can read the cloth
            // This is the main security check - users can only like clothes they can read
            // Check both subcollection and top-level collection paths
            allow create: if isAuthenticated() &&
                           likeId == request.auth.uid &&
                           request.resource.data.keys().hasAll(['userId', 'createdAt']) &&
                           request.resource.data.userId == request.auth.uid &&
                           request.resource.data.createdAt is timestamp &&
                           // Check if cloth exists in subcollection (current path) and is readable
                           ((exists(/databases/$(database)/documents/users/$(userId)/wardrobes/$(wardrobeId)/clothes/$(clothId)) &&
                             canReadCloth(get(/databases/$(database)/documents/users/$(userId)/wardrobes/$(wardrobeId)/clothes/$(clothId)).data)) ||
                            // Or check if cloth exists in top-level collection and is readable
                            (exists(/databases/$(database)/documents/clothes/$(clothId)) &&
                             canReadCloth(get(/databases/$(database)/documents/clothes/$(clothId)).data)));
            
            // Users can delete their own likes
            allow delete: if isAuthenticated() && likeId == request.auth.uid;
          }
          
          // Comments subcollection: clothes/{clothId}/comments/{commentId}
          match /comments/{commentId} {
            // Owner can do everything on their own cloths
            allow read, write: if isAuthenticated() && request.auth.uid == userId;
            
            // Allow list queries for authenticated users (needed for loading comments)
            // Individual document access is still controlled by get/create/update/delete rules below
            allow list: if isAuthenticated();
            
            // Others can read if authenticated and cloth is readable
            // Try both subcollection and top-level collection paths
            allow get: if isAuthenticated() && (
                        (exists(/databases/$(database)/documents/users/$(userId)/wardrobes/$(wardrobeId)/clothes/$(clothId)) &&
                         canReadCloth(get(/databases/$(database)/documents/users/$(userId)/wardrobes/$(wardrobeId)/clothes/$(clothId)).data)) ||
                        (exists(/databases/$(database)/documents/clothes/$(clothId)) &&
                         canReadCloth(get(/databases/$(database)/documents/clothes/$(clothId)).data))
                      );
            
            // Others can create comments if they can read the cloth
            // Check both subcollection and top-level collection paths
            allow create: if isAuthenticated() && 
                           request.resource.data.keys().hasAll(['userId', 'text', 'createdAt']) &&
                           request.resource.data.userId == request.auth.uid &&
                           request.resource.data.text is string &&
                           request.resource.data.text.size() > 0 &&
                           request.resource.data.createdAt is timestamp &&
                           // Check if cloth exists in subcollection and is readable
                           ((exists(/databases/$(database)/documents/users/$(userId)/wardrobes/$(wardrobeId)/clothes/$(clothId)) &&
                             canReadCloth(get(/databases/$(database)/documents/users/$(userId)/wardrobes/$(wardrobeId)/clothes/$(clothId)).data)) ||
                            // Or check if cloth exists in top-level collection and is readable
                            (exists(/databases/$(database)/documents/clothes/$(clothId)) &&
                             canReadCloth(get(/databases/$(database)/documents/clothes/$(clothId)).data)));
            
            // Users can update/delete their own comments if they can read the cloth
            allow update, delete: if isAuthenticated() &&
                                   resource.data.userId == request.auth.uid &&
                                   ((exists(/databases/$(database)/documents/users/$(userId)/wardrobes/$(wardrobeId)/clothes/$(clothId)) &&
                                     canReadCloth(get(/databases/$(database)/documents/users/$(userId)/wardrobes/$(wardrobeId)/clothes/$(clothId)).data)) ||
                                    (exists(/databases/$(database)/documents/clothes/$(clothId)) &&
                                     canReadCloth(get(/databases/$(database)/documents/clothes/$(clothId)).data)));
          }
        }
      }
      
      // Suggestions subcollection: users/{userId}/suggestions/{suggestionId}
      match /suggestions/{suggestionId} {
        allow read: if isOwner(userId);
        allow create: if isOwner(userId) &&
                         request.resource.data.keys().hasAll(['wardrobeId', 'clothIds', 'createdAt', 'viewed']) &&
                         request.resource.data.wardrobeId is string &&
                         request.resource.data.clothIds is list &&
                         request.resource.data.createdAt is timestamp &&
                         request.resource.data.viewed is bool;
        allow update: if isOwner(userId) &&
                         (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['viewed']) ||
                          request.resource.data.viewed is bool);
        allow delete: if isOwner(userId);
      }
      
      // Chats subcollection: users/{userId}/chats/{chatId}
      match /chats/{chatId} {
        // Allow list queries for the owner (needed for chat list)
        // Note: Individual document access is still controlled by get rule
        allow list: if isOwner(userId);
        
        // Allow read if user is a participant
        allow get: if isAuthenticated() && 
                     request.auth.uid in resource.data.participants;
        
        // Allow create if:
        // 1. User owns the userId path (creating chat in their own list), OR
        // 2. User is a participant in the chat (allows bidirectional chat creation)
        //    This allows user A to create a chat document in user B's chats subcollection
        //    when they are both participants in the chat.
        allow create: if (isOwner(userId) && 
                         isValidChat(request.resource.data) &&
                         request.auth.uid in request.resource.data.participants) ||
                        (isAuthenticated() && 
                         isValidChat(request.resource.data) &&
                         request.auth.uid in request.resource.data.participants &&
                         userId in request.resource.data.participants);
        allow update: if isAuthenticated() && 
                         request.auth.uid in resource.data.participants &&
                         isValidChat(request.resource.data);
        allow delete: if isAuthenticated() && 
                         request.auth.uid in resource.data.participants;
        
        // Messages subcollection: chats/{chatId}/messages/{messageId}
        match /messages/{messageId} {
          // Allow list queries for participants (needed for loading messages)
          // Check if chat exists and user is a participant
          allow list: if isAuthenticated() && 
                         (exists(/databases/$(database)/documents/users/$(userId)/chats/$(chatId)) &&
                          request.auth.uid in get(/databases/$(database)/documents/users/$(userId)/chats/$(chatId)).data.participants);
          
          // Allow read if user is a participant in parent chat
          allow read: if isAuthenticated() && 
                         request.auth.uid in get(/databases/$(database)/documents/users/$(userId)/chats/$(chatId)).data.participants;
          
          // Allow create if:
          // 1. User is a participant in the chat (can create in their own subcollection), OR
          // 2. User is the sender and is a participant (allows creating in other participants' subcollections)
          // This allows bidirectional message creation - when User A sends a message,
          // it can be created in both User A's and User B's message subcollections
          allow create: if isAuthenticated() && 
                           isValidMessage(request.resource.data) &&
                           request.resource.data.senderId == request.auth.uid &&
                           // Check if sender is a participant in the chat
                           // We check the chat document at the userId path (which may be different from sender)
                           // but both users should have the same chat with same participants
                           request.auth.uid in get(/databases/$(database)/documents/users/$(userId)/chats/$(chatId)).data.participants;
          allow update: if isAuthenticated() && 
                           request.auth.uid in get(/databases/$(database)/documents/users/$(userId)/chats/$(chatId)).data.participants &&
                           (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['seenBy']) ||
                            (resource.data.senderId == request.auth.uid && isValidMessage(request.resource.data)));
          allow delete: if isAuthenticated() && 
                           request.auth.uid in get(/databases/$(database)/documents/users/$(userId)/chats/$(chatId)).data.participants &&
                           resource.data.senderId == request.auth.uid;
        }
      }
    }
    
    // ============================================
    // FRIEND REQUESTS COLLECTION
    // ============================================
    match /friendRequests/{requestId} {
      // Allow list queries (for querying by toUserId/fromUserId)
      // User can query for requests where they are sender or receiver
      // Note: The where clauses in the query will filter results, but we need to allow the query itself
      allow list: if isAuthenticated();
      
      // Allow read if user is sender or receiver
      allow read: if isAuthenticated() && 
                     (resource.data.fromUserId == request.auth.uid || 
                      resource.data.toUserId == request.auth.uid);
      
      // Allow create if user is the sender
      allow create: if isAuthenticated() && 
                       isValidFriendRequest(request.resource.data) &&
                       request.resource.data.fromUserId == request.auth.uid &&
                       request.resource.data.status == 'pending';
      
      // Allow update if user is receiver (accept/reject) or sender (cancel)
      allow update: if isAuthenticated() && 
                       isValidFriendRequest(request.resource.data) &&
                       ((resource.data.toUserId == request.auth.uid && 
                         request.resource.data.status in ['accepted', 'rejected']) ||
                        (resource.data.fromUserId == request.auth.uid && 
                         request.resource.data.status == 'canceled'));
      
      // Allow delete if user is sender or receiver
      allow delete: if isAuthenticated() && 
                       (resource.data.fromUserId == request.auth.uid || 
                        resource.data.toUserId == request.auth.uid);
    }
    
    // ============================================
    // CLOTHES COLLECTION (Top-level for queries)
    // ============================================
    // Note: Clothes are stored in users/{userId}/wardrobes/{wardrobeId}/clothes/{clothId}
    // This top-level collection is for querying across all clothes (if needed)
    // Also allows writes to sync with subcollection
    match /clothes/{clothId} {
      // Allow list for authenticated users (needed for queries and document access)
      // Individual document access is still controlled by get rule below
      allow list: if isAuthenticated();
      
      // Allow read based on cloth visibility
      // Check canReadCloth to ensure proper permissions (owner, public, friends, or sharedWith)
      allow get: if isAuthenticated() && 
                   resource.data != null &&
                   canReadCloth(resource.data);
      // Allow write if user owns the cloth (ownerId matches authenticated user)
      allow create: if isAuthenticated() && 
                      request.resource.data.ownerId == request.auth.uid &&
                      isValidCloth(request.resource.data);
      // Allow authenticated users to update likesCount when liking/unliking
      // Check if cloth exists and is readable via subcollection path
      allow update: if isAuthenticated() &&
                      'ownerId' in resource.data &&
                      'wardrobeId' in resource.data &&
                      request.resource.data.commentsCount == resource.data.commentsCount &&
                      request.resource.data.ownerId == resource.data.ownerId &&
                      request.resource.data.wardrobeId == resource.data.wardrobeId &&
                      request.resource.data.imageUrl == resource.data.imageUrl &&
                      'updatedAt' in request.resource.data &&
                      request.resource.data.likesCount is int &&
                      // Verify cloth exists and is readable (check subcollection)
                      exists(/databases/$(database)/documents/users/$(resource.data.ownerId)/wardrobes/$(resource.data.wardrobeId)/clothes/$(clothId)) &&
                      canReadCloth(get(/databases/$(database)/documents/users/$(resource.data.ownerId)/wardrobes/$(resource.data.wardrobeId)/clothes/$(clothId)).data);
      
      // Allow authenticated users to update commentsCount when adding/deleting comments
      // Check if cloth exists and is readable via subcollection path
      allow update: if isAuthenticated() &&
                      'ownerId' in resource.data &&
                      'wardrobeId' in resource.data &&
                      request.resource.data.likesCount == resource.data.likesCount &&
                      request.resource.data.ownerId == resource.data.ownerId &&
                      request.resource.data.wardrobeId == resource.data.wardrobeId &&
                      request.resource.data.imageUrl == resource.data.imageUrl &&
                      'updatedAt' in request.resource.data &&
                      request.resource.data.commentsCount is int &&
                      // Verify cloth exists and is readable (check subcollection)
                      exists(/databases/$(database)/documents/users/$(resource.data.ownerId)/wardrobes/$(resource.data.wardrobeId)/clothes/$(clothId)) &&
                      canReadCloth(get(/databases/$(database)/documents/users/$(resource.data.ownerId)/wardrobes/$(resource.data.wardrobeId)/clothes/$(clothId)).data);
      
      // Allow owner to update sharedWith array (for sharing clothes via DM)
      // This allows updating sharedWith and updatedAt only
      allow update: if isAuthenticated() &&
                      resource.data.ownerId == request.auth.uid &&
                      request.resource.data.ownerId == request.auth.uid &&
                      request.resource.data.likesCount == resource.data.likesCount &&
                      request.resource.data.commentsCount == resource.data.commentsCount &&
                      'updatedAt' in request.resource.data &&
                      (!('sharedWith' in request.resource.data) || request.resource.data.sharedWith is list) &&
                      // Ensure other critical fields are unchanged
                      request.resource.data.wardrobeId == resource.data.wardrobeId &&
                      request.resource.data.imageUrl == resource.data.imageUrl &&
                      request.resource.data.clothType == resource.data.clothType &&
                      request.resource.data.category == resource.data.category &&
                      request.resource.data.season == resource.data.season;
      
      // Allow partial update for wear tracking (requires updatedAt)
      allow update: if isAuthenticated() && 
                      (!('ownerId' in resource.data) || resource.data.ownerId == request.auth.uid) &&
                      (!('ownerId' in request.resource.data) || request.resource.data.ownerId == request.auth.uid) &&
                      request.resource.data.likesCount == resource.data.likesCount &&
                      request.resource.data.commentsCount == resource.data.commentsCount &&
                      'updatedAt' in request.resource.data &&
                      (!('wornAt' in request.resource.data) || request.resource.data.wornAt is timestamp);
      // Allow full cloth update (all fields required)
      allow update: if isAuthenticated() && 
                      (!('ownerId' in resource.data) || resource.data.ownerId == request.auth.uid) &&
                      (!('ownerId' in request.resource.data) || request.resource.data.ownerId == request.auth.uid) &&
                      request.resource.data.likesCount == resource.data.likesCount &&
                      request.resource.data.commentsCount == resource.data.commentsCount &&
                      isValidCloth(request.resource.data);
      allow delete: if isAuthenticated() && 
                      resource.data.ownerId == request.auth.uid;
    }
    
    // ============================================
    // WARDROBES COLLECTION (Top-level for queries)
    // ============================================
    // Note: Wardrobes are stored in users/{userId}/wardrobes/{wardrobeId}
    // This top-level collection is for querying across all wardrobes (if needed)
    // Also allows writes to sync with subcollection
    match /wardrobes/{wardrobeId} {
      allow read: if isAuthenticated();
      // Allow write if user owns the wardrobe (ownerId matches authenticated user)
      allow create: if isAuthenticated() && 
                      request.resource.data.ownerId == request.auth.uid &&
                      isValidWardrobe(request.resource.data);
      allow update: if isAuthenticated() && 
                      resource.data.ownerId == request.auth.uid &&
                      request.resource.data.ownerId == request.auth.uid &&
                      isValidWardrobe(request.resource.data);
      allow delete: if isAuthenticated() && 
                      resource.data.ownerId == request.auth.uid;
    }
    
    // ============================================
    // CHATS COLLECTION (Top-level for queries)
    // ============================================
    // Note: Chats are stored in users/{userId}/chats/{chatId}
    // This top-level collection is for querying across all chats (if needed)
    match /chats/{chatId} {
      allow read: if isAuthenticated() && 
                     request.auth.uid in resource.data.participants;
      // Allow create if user is a participant (needed for bidirectional chat creation)
      allow create: if isAuthenticated() && 
                       isValidChat(request.resource.data) &&
                       request.auth.uid in request.resource.data.participants;
      // Allow update if user is a participant
      allow update: if isAuthenticated() && 
                       request.auth.uid in resource.data.participants &&
                       isValidChat(request.resource.data);
      // Allow delete if user is a participant
      allow delete: if isAuthenticated() && 
                       request.auth.uid in resource.data.participants;
    }
    
    // ============================================
    // NOTIFICATION TRIGGERS COLLECTION
    // ============================================
    // Used to trigger push notifications via Cloud Functions
    // Cloud Functions listen to this collection and send FCM notifications
    match /notificationTriggers/{triggerId} {
      // Allow authenticated users to create notification triggers
      // This allows users to trigger notifications for other users
      // Cloud Functions will process these and send actual FCM notifications
      allow create: if isAuthenticated() && 
                       request.resource.data.keys().hasAll(['type', 'recipientUserId', 'senderUserId', 'createdAt']) &&
                       request.resource.data.type is string &&
                       request.resource.data.recipientUserId is string &&
                       request.resource.data.senderUserId is string &&
                       request.resource.data.senderUserId == request.auth.uid &&
                       request.resource.data.createdAt is timestamp;
      
      // Only Cloud Functions should read/update/delete these
      // For now, allow read for debugging (can be restricted later)
      allow read: if isAuthenticated();
      allow update, delete: if false; // Only Cloud Functions can update/delete
    }
    
    // ============================================
    // FCM TOKENS COLLECTION
    // ============================================
    // Stores FCM tokens linked to users for easy notification sending
    // Structure: fcmTokens/{tokenId} -> { userId, fcmToken, platform, deviceName, isActive, lastActiveAt, createdAt }
    match /fcmTokens/{tokenId} {
      // Allow users to create their own tokens
      allow create: if isAuthenticated() &&
                       request.resource.data.keys().hasAll(['userId', 'fcmToken', 'platform', 'createdAt']) &&
                       request.resource.data.userId == request.auth.uid &&
                       request.resource.data.userId is string &&
                       request.resource.data.fcmToken is string &&
                       request.resource.data.platform is string &&
                       request.resource.data.createdAt is timestamp;
      
      // Allow users to update their own tokens (for lastActiveAt, isActive)
      // When using set() with merge: true, if document exists it uses update rule
      allow update: if isAuthenticated() &&
                       // User must own the token (userId in request matches auth user)
                       'userId' in request.resource.data &&
                       request.resource.data.userId == request.auth.uid &&
                       // If document exists, verify user owns it
                       (!('userId' in resource.data) || resource.data.userId == request.auth.uid);
      
      // Allow users to read their own tokens
      allow read: if isAuthenticated() && 
                     (!exists(/databases/$(database)/documents/fcmTokens/$(tokenId)) ||
                      resource.data.userId == request.auth.uid);
      
      // Allow list queries for authenticated users (needed for Cloud Functions to query by userId)
      // Individual document access is still controlled by read rule above
      allow list: if isAuthenticated();
      
      // Allow delete (users can delete their own tokens)
      allow delete: if isAuthenticated() && 
                      exists(/databases/$(database)/documents/fcmTokens/$(tokenId)) &&
                      resource.data.userId == request.auth.uid;
    }
  }
}
