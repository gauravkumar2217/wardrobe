rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // ============================================
    // AUTHENTICATION SUPPORT
    // ============================================
    // These rules support multiple authentication methods:
    // 1. Phone Number Authentication (OTP verification)
    // 2. Google Sign-In Authentication (OAuth)
    // 3. Email/Password Authentication
    // 
    // All methods use Firebase Authentication and provide a unified user ID (uid)
    // The isOwner() function works for all authentication providers
    
    // ============================================
    // HELPER FUNCTIONS
    // ============================================
    
    // Helper function to check if user is authenticated
    // Works for Phone, Google, and Email authentication
    function isAuthenticated() {
      return request.auth != null;
    }
    
    // Helper function to check if user owns the resource
    // Works for all authentication methods
    // Firebase Auth provides a unified uid regardless of authentication provider
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    // Helper function to check if user can read cloth
    // Note: Friend visibility checks are handled at application level
    // as Firestore rules cannot use request.auth.uid in document paths
    function canReadCloth(clothData) {
      // Owner can always read
      return request.auth != null && (
        request.auth.uid == clothData.ownerId ||
        // Public visibility - anyone authenticated can read
        (isAuthenticated() && clothData.visibility == 'public') ||
        // Shared with specific users
        (isAuthenticated() && clothData.sharedWith != null && request.auth.uid in clothData.sharedWith)
      );
    }
    
    // Helper function to validate user profile data
    function isValidUserProfile(data) {
      return (!('displayName' in data) || data.displayName is string) &&
             (!('username' in data) || (data.username is string && 
                                        data.username.size() >= 3 && 
                                        data.username.size() <= 20 &&
                                        data.username.matches('^[a-z0-9_]+$'))) &&
             (!('photoUrl' in data) || data.photoUrl is string) &&
             (!('email' in data) || data.email is string) &&
             (!('phone' in data) || data.phone is string) &&
             (!('phoneNumber' in data) || data.phoneNumber is string) &&
             (!('gender' in data) || data.gender in ['male', 'female', 'other']) &&
             (!('dateOfBirth' in data) || data.dateOfBirth is timestamp) &&
             (!('createdAt' in data) || data.createdAt is timestamp) &&
             (!('updatedAt' in data) || data.updatedAt is timestamp) &&
             (!('settings' in data) || data.settings is map);
    }
    
    // Helper function to check if username is being changed (should be immutable after creation)
    function isUsernameUnchanged(data, existingData) {
      return !('username' in data) || 
             (existingData != null && 
              'username' in existingData && 
              data.username == existingData.username);
    }
    
    // Helper function to validate wardrobe data
    function isValidWardrobe(data) {
      return data.keys().hasAll(['ownerId', 'name', 'location', 'createdAt', 'updatedAt']) &&
             data.ownerId is string &&
             data.name is string &&
             data.name.size() > 0 &&
             data.location is string &&
             data.location.size() > 0 &&
             data.createdAt is timestamp &&
             data.updatedAt is timestamp &&
             (!('totalItems' in data) || data.totalItems is int);
    }
    
    // Helper function to validate cloth data
    function isValidCloth(data) {
      return data.keys().hasAll(['ownerId', 'wardrobeId', 'imageUrl', 'season', 'placement', 'clothType', 'category', 'occasions', 'colorTags', 'createdAt', 'updatedAt']) &&
             data.ownerId is string &&
             data.wardrobeId is string &&
             data.imageUrl is string &&
             data.season is string &&
             data.placement is string &&
             data.clothType is string &&
             data.category is string &&
             data.occasions is list &&
             data.occasions.size() > 0 &&
             data.colorTags is map &&
             data.createdAt is timestamp &&
             data.updatedAt is timestamp &&
             (!('wornAt' in data) || data.wornAt is timestamp) &&
             (!('visibility' in data) || data.visibility in ['private', 'friends', 'public']) &&
             (!('sharedWith' in data) || data.sharedWith is list) &&
             (!('likesCount' in data) || data.likesCount is int) &&
             (!('commentsCount' in data) || data.commentsCount is int);
    }
    
    // Helper function to validate partial cloth update (for lastWornAt updates)
    function isValidClothPartialUpdate(data) {
      // Allow updating only lastWornAt and updatedAt fields
      // updatedAt is typically FieldValue.serverTimestamp() which is handled server-side
      // We only validate that lastWornAt is a timestamp
      return data.keys().size() == 2 &&
             'lastWornAt' in data &&
             'updatedAt' in data &&
             data.lastWornAt is timestamp;
    }
    
    // Helper function to check if update is a valid partial or full update
    function isValidClothUpdate(newData, existingData) {
      // If update includes only lastWornAt and updatedAt (partial update for wear tracking)
      // use partial validation - this allows FieldValue.serverTimestamp() for updatedAt
      // Otherwise, validate as full cloth update
      return ('lastWornAt' in newData && 
              'updatedAt' in newData &&
              newData.keys().size() == 2) 
             ? isValidClothPartialUpdate(newData)
             : isValidCloth(newData);
    }
    
    // Helper function to validate friend request data
    function isValidFriendRequest(data) {
      return data.keys().hasAll(['fromUserId', 'toUserId', 'status', 'createdAt', 'updatedAt']) &&
             data.fromUserId is string &&
             data.toUserId is string &&
             data.status in ['pending', 'accepted', 'rejected', 'canceled'] &&
             data.createdAt is timestamp &&
             data.updatedAt is timestamp;
    }
    
    // Helper function to validate chat data
    function isValidChat(data) {
      return data.keys().hasAll(['participants', 'createdAt']) &&
             data.participants is list &&
             data.participants.size() >= 2 &&
             (!('lastMessage' in data) || data.lastMessage is string) &&
             (!('lastMessageAt' in data) || data.lastMessageAt is timestamp) &&
             (!('isGroup' in data) || data.isGroup is bool) &&
             data.createdAt is timestamp;
    }
    
    // Helper function to validate message data
    function isValidMessage(data) {
      return data.keys().hasAll(['senderId', 'createdAt']) &&
             data.senderId is string &&
             (!('text' in data) || data.text is string) &&
             (!('imageUrl' in data) || data.imageUrl is string) &&
             (!('clothId' in data) || data.clothId is string) &&
             (!('seenBy' in data) || data.seenBy is list) &&
             data.createdAt is timestamp;
    }
    
    // Helper function to validate notification data
    function isValidNotification(data) {
      return data.keys().hasAll(['type', 'title', 'body', 'createdAt', 'read']) &&
             data.type in ['friend_request', 'friend_accept', 'dm_message', 'cloth_like', 'cloth_comment', 'suggestion'] &&
             data.title is string &&
             data.body is string &&
             (!('data' in data) || data.data is map) &&
             data.createdAt is timestamp &&
             data.read is bool;
    }
    
    // Helper function to validate device data
    function isValidDevice(data) {
      return data.keys().hasAll(['fcmToken', 'platform', 'isActive', 'lastActiveAt', 'createdAt']) &&
             data.fcmToken is string &&
             data.fcmToken.size() > 0 &&
             data.platform in ['android', 'ios', 'web'] &&
             data.isActive is bool &&
             data.lastActiveAt is timestamp &&
             (!('deviceName' in data) || data.deviceName is string) &&
             data.createdAt is timestamp;
    }
    
    // ============================================
    // CONFIG COLLECTION
    // ============================================
    // Tag Lists: config/tagLists
    // Read: Public (needed for app functionality before authentication)
    // Write: Admin only (configure user IDs in rules)
    match /config/{configId} {
      // Allow public read for config documents (needed for tagLists before user authentication)
      // This is safe as config data is non-sensitive app configuration
      allow read: if true;
      
      // Only admins can write (replace with your admin user IDs)
      allow write: if isAuthenticated() && 
                      (request.auth.uid == 'YOUR_ADMIN_USER_ID_1' || 
                       request.auth.uid == 'YOUR_ADMIN_USER_ID_2' ||
                       request.auth.token.admin == true);
    }
    
    // ============================================
    // USERS COLLECTION
    // ============================================
    match /users/{userId} {
      // Allow list queries (for username/email lookups during login)
      // This allows unauthenticated queries on username field for login functionality
      allow list: if true; // Allow queries for username lookups (needed before authentication)
      
      // Allow read if:
      // 1. User owns the profile (full access)
      // 2. Unauthenticated users can read username/email for login queries
      // 3. Authenticated users can read basic profile info
      allow get: if isOwner(userId) || 
                     // Allow unauthenticated reads for username/email (needed for login)
                     (!isAuthenticated() && 
                      ('username' in resource.data || 'email' in resource.data)) ||
                     // Allow authenticated users to read basic profile info
                     (isAuthenticated() && 
                      ('username' in resource.data || 
                       'email' in resource.data ||
                       resource.data.keys().hasAll(['displayName', 'photoUrl'])));
      
      // Allow create if user owns the profile
      // Username must be provided and valid on creation
      allow create: if isOwner(userId) && 
                       isValidUserProfile(request.resource.data) &&
                       ('username' in request.resource.data) &&
                       request.resource.data.username is string &&
                       request.resource.data.username.size() >= 3 &&
                       request.resource.data.username.size() <= 20 &&
                       request.resource.data.username.matches('^[a-z0-9_]+$');
      
      // Allow update if user owns the profile
      // Username cannot be changed after creation (immutable)
      allow update: if isOwner(userId) && 
                       isValidUserProfile(request.resource.data) &&
                       isUsernameUnchanged(request.resource.data, resource.data);
      
      // Allow delete if user owns the profile
      allow delete: if isOwner(userId);
      
      // Friends subcollection: users/{userId}/friends/{friendId}
      match /friends/{friendId} {
        allow read: if isOwner(userId);
        // Allow create if:
        // 1. User owns the userId path (adding friend to their own list), OR
        // 2. User is the friendId (the other person in the friendship)
        //    This allows bidirectional friend creation when accepting a request.
        //    The application logic ensures this only happens when there's an accepted friend request.
        //    Security: Users can only add themselves (as friendId) to another user's friends list,
        //    which is safe since they're just adding their own ID.
        allow create: if (isOwner(userId) && 
                         request.resource.data.keys().hasAll(['friendId', 'createdAt']) &&
                         request.resource.data.friendId == friendId &&
                         request.resource.data.friendId is string &&
                         request.resource.data.createdAt is timestamp) ||
                        (isAuthenticated() && 
                         request.auth.uid == friendId &&
                         request.resource.data.keys().hasAll(['friendId', 'createdAt']) &&
                         request.resource.data.friendId == friendId &&
                         request.resource.data.friendId is string &&
                         request.resource.data.createdAt is timestamp);
        allow delete: if isOwner(userId);
      }
      
      // Notifications subcollection: users/{userId}/notifications/{notificationId}
      match /notifications/{notificationId} {
        allow read: if isOwner(userId);
        allow create: if isOwner(userId) && isValidNotification(request.resource.data);
        allow update: if isOwner(userId) && 
                         (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['read']) ||
                          isValidNotification(request.resource.data));
        allow delete: if isOwner(userId);
      }
      
      // Devices subcollection: users/{userId}/devices/{deviceId}
      match /devices/{deviceId} {
        allow read: if isOwner(userId);
        allow create: if isOwner(userId) && isValidDevice(request.resource.data);
        allow update: if isOwner(userId) && isValidDevice(request.resource.data);
        allow delete: if isOwner(userId);
      }
      
      // FCM Tokens subcollection: users/{userId}/fcmTokens/{tokenId}
      match /fcmTokens/{tokenId} {
        allow read: if isOwner(userId);
        allow create: if isOwner(userId) &&
                         request.resource.data.keys().hasAll(['token', 'userId', 'isActive', 'lastActive', 'createdAt', 'updatedAt']) &&
                         request.resource.data.token is string &&
                         request.resource.data.userId == userId;
        allow update: if isOwner(userId);
        allow delete: if isOwner(userId);
      }
      
      // Wardrobes subcollection: users/{userId}/wardrobes/{wardrobeId}
      match /wardrobes/{wardrobeId} {
        // Allow read if user owns the wardrobe or visibility allows
        // Note: Friend check for 'friends' visibility is handled at application level
        // as Firestore rules cannot use request.auth.uid in document paths
        allow read: if isOwner(userId) || 
                       (isAuthenticated() && 
                        resource.data.ownerId == userId &&
                        resource.data.visibility == 'public');
        
        allow create: if isOwner(userId) && isValidWardrobe(request.resource.data);
        allow update: if isOwner(userId) && isValidWardrobe(request.resource.data);
        allow delete: if isOwner(userId);
        
        // Clothes subcollection: users/{userId}/wardrobes/{wardrobeId}/clothes/{clothId}
        match /clothes/{clothId} {
          // Allow list queries for wardrobe owner (needed for deletion and listing)
          allow list: if isOwner(userId);
          
          // Allow read based on cloth visibility
          allow get: if canReadCloth(resource.data);
          
          allow create: if isOwner(userId) && isValidCloth(request.resource.data);
          
          // Allow authenticated users to update likesCount when liking/unliking
          // This allows any authenticated user who can read the cloth to update likesCount
          allow update: if isAuthenticated() &&
                           canReadCloth(resource.data) &&
                           request.resource.data.commentsCount == resource.data.commentsCount &&
                           'updatedAt' in request.resource.data &&
                           // Only allow updating likesCount and updatedAt
                           // Note: FieldValue.increment() may not work with diff(), so we check that
                           // other critical fields are unchanged
                           request.resource.data.ownerId == resource.data.ownerId &&
                           request.resource.data.wardrobeId == resource.data.wardrobeId &&
                           request.resource.data.imageUrl == resource.data.imageUrl &&
                           request.resource.data.likesCount is int;
          
          // Allow authenticated users to update commentsCount when adding/deleting comments
          // This allows any authenticated user who can read the cloth to update commentsCount
          allow update: if isAuthenticated() &&
                           canReadCloth(resource.data) &&
                           request.resource.data.likesCount == resource.data.likesCount &&
                           'updatedAt' in request.resource.data &&
                           // Only allow updating commentsCount and updatedAt
                           // Note: FieldValue.increment() may not work with diff(), so we check that
                           // other critical fields are unchanged
                           request.resource.data.ownerId == resource.data.ownerId &&
                           request.resource.data.wardrobeId == resource.data.wardrobeId &&
                           request.resource.data.imageUrl == resource.data.imageUrl &&
                           request.resource.data.commentsCount is int;
          
          // Allow partial update for wear tracking (wornAt + updatedAt)
          // Ensure system fields (likes/comments) are unchanged
          allow update: if isOwner(userId) && 
                           request.resource.data.likesCount == resource.data.likesCount &&
                           request.resource.data.commentsCount == resource.data.commentsCount &&
                           'updatedAt' in request.resource.data &&
                           (!('wornAt' in request.resource.data) || request.resource.data.wornAt is timestamp);
          
          // Allow full cloth updates (e.g., edit cloth details)
          allow update: if isOwner(userId) &&
                           request.resource.data.likesCount == resource.data.likesCount &&
                           request.resource.data.commentsCount == resource.data.commentsCount &&
                           isValidCloth(request.resource.data);
          
          allow delete: if isOwner(userId);
          
          // Wear history subcollection: clothes/{clothId}/wearHistory/{entryId}
          match /wearHistory/{entryId} {
            allow read: if isOwner(userId);
            allow create: if isOwner(userId) &&
                             request.resource.data.keys().hasAll(['userId', 'wornAt', 'source']) &&
                             request.resource.data.userId == userId &&
                             request.resource.data.wornAt is timestamp &&
                             request.resource.data.source in ['manual', 'scheduledSuggestion'];
            allow delete: if isOwner(userId);
          }
          
          // Likes subcollection: clothes/{clothId}/likes/{likeId}
          match /likes/{likeId} {
            // SIMPLIFIED RULES - Owner can do everything on their own cloths
            allow read, write: if isAuthenticated() && request.auth.uid == userId;
            
            // Others can read if authenticated and cloth is readable
            allow read: if isAuthenticated() &&
                        exists(/databases/$(database)/documents/users/$(userId)/wardrobes/$(wardrobeId)/clothes/$(clothId)) &&
                        canReadCloth(get(/databases/$(database)/documents/users/$(userId)/wardrobes/$(wardrobeId)/clothes/$(clothId)).data);
            
            // Others can create likes if they can read the cloth
            allow create: if isAuthenticated() &&
                           likeId == request.auth.uid &&
                           request.resource.data.keys().hasAll(['userId', 'createdAt']) &&
                           request.resource.data.userId == request.auth.uid &&
                           request.resource.data.createdAt is timestamp &&
                           exists(/databases/$(database)/documents/users/$(userId)/wardrobes/$(wardrobeId)/clothes/$(clothId)) &&
                           canReadCloth(get(/databases/$(database)/documents/users/$(userId)/wardrobes/$(wardrobeId)/clothes/$(clothId)).data);
            
            // Users can delete their own likes (simplified - if they created it, they can delete it)
            allow delete: if isAuthenticated() && likeId == request.auth.uid;
          }
          
          // Comments subcollection: clothes/{clothId}/comments/{commentId}
          match /comments/{commentId} {
            // SIMPLIFIED RULES - Owner can do everything on their own cloths
            allow read, write: if isAuthenticated() && request.auth.uid == userId;
            
            // Others can read if authenticated and cloth is readable
            allow read: if isAuthenticated() &&
                        exists(/databases/$(database)/documents/users/$(userId)/wardrobes/$(wardrobeId)/clothes/$(clothId)) &&
                        canReadCloth(get(/databases/$(database)/documents/users/$(userId)/wardrobes/$(wardrobeId)/clothes/$(clothId)).data);
            
            // Others can create comments if they can read the cloth
            allow create: if isAuthenticated() && 
                           request.resource.data.keys().hasAll(['userId', 'text', 'createdAt']) &&
                           request.resource.data.userId == request.auth.uid &&
                           request.resource.data.text is string &&
                           request.resource.data.text.size() > 0 &&
                           request.resource.data.createdAt is timestamp &&
                           exists(/databases/$(database)/documents/users/$(userId)/wardrobes/$(wardrobeId)/clothes/$(clothId)) &&
                           canReadCloth(get(/databases/$(database)/documents/users/$(userId)/wardrobes/$(wardrobeId)/clothes/$(clothId)).data);
            
            // Users can update/delete their own comments if they can read the cloth
            allow update, delete: if isAuthenticated() &&
                                   resource.data.userId == request.auth.uid &&
                                   exists(/databases/$(database)/documents/users/$(userId)/wardrobes/$(wardrobeId)/clothes/$(clothId)) &&
                                   canReadCloth(get(/databases/$(database)/documents/users/$(userId)/wardrobes/$(wardrobeId)/clothes/$(clothId)).data);
          }
        }
      }
      
      // Suggestions subcollection: users/{userId}/suggestions/{suggestionId}
      match /suggestions/{suggestionId} {
        allow read: if isOwner(userId);
        allow create: if isOwner(userId) &&
                         request.resource.data.keys().hasAll(['wardrobeId', 'clothIds', 'createdAt', 'viewed']) &&
                         request.resource.data.wardrobeId is string &&
                         request.resource.data.clothIds is list &&
                         request.resource.data.createdAt is timestamp &&
                         request.resource.data.viewed is bool;
        allow update: if isOwner(userId) &&
                         (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['viewed']) ||
                          request.resource.data.viewed is bool);
        allow delete: if isOwner(userId);
      }
      
      // Chats subcollection: users/{userId}/chats/{chatId}
      match /chats/{chatId} {
        // Allow list queries for the owner (needed for chat list)
        allow list: if isOwner(userId);
        
        // Allow read if user is a participant
        allow get: if isAuthenticated() && 
                     request.auth.uid in resource.data.participants;
        
        allow create: if isAuthenticated() && 
                         isValidChat(request.resource.data) &&
                         request.auth.uid in request.resource.data.participants;
        allow update: if isAuthenticated() && 
                         request.auth.uid in resource.data.participants &&
                         isValidChat(request.resource.data);
        allow delete: if isAuthenticated() && 
                         request.auth.uid in resource.data.participants;
        
        // Messages subcollection: chats/{chatId}/messages/{messageId}
        match /messages/{messageId} {
          // Allow read if user is a participant in parent chat
          allow read: if isAuthenticated() && 
                         request.auth.uid in get(/databases/$(database)/documents/users/$(userId)/chats/$(chatId)).data.participants;
          
          allow create: if isAuthenticated() && 
                           request.auth.uid in get(/databases/$(database)/documents/users/$(userId)/chats/$(chatId)).data.participants &&
                           isValidMessage(request.resource.data) &&
                           request.resource.data.senderId == request.auth.uid;
          allow update: if isAuthenticated() && 
                           request.auth.uid in get(/databases/$(database)/documents/users/$(userId)/chats/$(chatId)).data.participants &&
                           (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['seenBy']) ||
                            (resource.data.senderId == request.auth.uid && isValidMessage(request.resource.data)));
          allow delete: if isAuthenticated() && 
                           request.auth.uid in get(/databases/$(database)/documents/users/$(userId)/chats/$(chatId)).data.participants &&
                           resource.data.senderId == request.auth.uid;
        }
      }
    }
    
    // ============================================
    // FRIEND REQUESTS COLLECTION
    // ============================================
    match /friendRequests/{requestId} {
      // Allow list queries (for querying by toUserId/fromUserId)
      // User can query for requests where they are sender or receiver
      allow list: if isAuthenticated();
      
      // Allow read if user is sender or receiver
      allow read: if isAuthenticated() && 
                     (resource.data.fromUserId == request.auth.uid || 
                      resource.data.toUserId == request.auth.uid);
      
      // Allow create if user is the sender
      allow create: if isAuthenticated() && 
                       isValidFriendRequest(request.resource.data) &&
                       request.resource.data.fromUserId == request.auth.uid &&
                       request.resource.data.status == 'pending';
      
      // Allow update if user is receiver (accept/reject) or sender (cancel)
      allow update: if isAuthenticated() && 
                       isValidFriendRequest(request.resource.data) &&
                       ((resource.data.toUserId == request.auth.uid && 
                         request.resource.data.status in ['accepted', 'rejected']) ||
                        (resource.data.fromUserId == request.auth.uid && 
                         request.resource.data.status == 'canceled'));
      
      // Allow delete if user is sender or receiver
      allow delete: if isAuthenticated() && 
                       (resource.data.fromUserId == request.auth.uid || 
                        resource.data.toUserId == request.auth.uid);
    }
    
    // ============================================
    // CLOTHES COLLECTION (Top-level for queries)
    // ============================================
    // Note: Clothes are stored in users/{userId}/wardrobes/{wardrobeId}/clothes/{clothId}
    // This top-level collection is for querying across all clothes (if needed)
    // Also allows writes to sync with subcollection
    match /clothes/{clothId} {
      // Allow read based on cloth visibility (requires fetching cloth document)
      // This is a simplified rule - actual access should be checked via the cloth document
      allow read: if isAuthenticated();
      // Allow write if user owns the cloth (ownerId matches authenticated user)
      allow create: if isAuthenticated() && 
                      request.resource.data.ownerId == request.auth.uid &&
                      isValidCloth(request.resource.data);
      // Allow authenticated users to update likesCount when liking/unliking
      // Check if cloth exists and is readable via subcollection path
      allow update: if isAuthenticated() &&
                      'ownerId' in resource.data &&
                      'wardrobeId' in resource.data &&
                      request.resource.data.commentsCount == resource.data.commentsCount &&
                      request.resource.data.ownerId == resource.data.ownerId &&
                      request.resource.data.wardrobeId == resource.data.wardrobeId &&
                      request.resource.data.imageUrl == resource.data.imageUrl &&
                      'updatedAt' in request.resource.data &&
                      request.resource.data.likesCount is int &&
                      // Verify cloth exists and is readable (check subcollection)
                      exists(/databases/$(database)/documents/users/$(resource.data.ownerId)/wardrobes/$(resource.data.wardrobeId)/clothes/$(clothId)) &&
                      canReadCloth(get(/databases/$(database)/documents/users/$(resource.data.ownerId)/wardrobes/$(resource.data.wardrobeId)/clothes/$(clothId)).data);
      
      // Allow authenticated users to update commentsCount when adding/deleting comments
      // Check if cloth exists and is readable via subcollection path
      allow update: if isAuthenticated() &&
                      'ownerId' in resource.data &&
                      'wardrobeId' in resource.data &&
                      request.resource.data.likesCount == resource.data.likesCount &&
                      request.resource.data.ownerId == resource.data.ownerId &&
                      request.resource.data.wardrobeId == resource.data.wardrobeId &&
                      request.resource.data.imageUrl == resource.data.imageUrl &&
                      'updatedAt' in request.resource.data &&
                      request.resource.data.commentsCount is int &&
                      // Verify cloth exists and is readable (check subcollection)
                      exists(/databases/$(database)/documents/users/$(resource.data.ownerId)/wardrobes/$(resource.data.wardrobeId)/clothes/$(clothId)) &&
                      canReadCloth(get(/databases/$(database)/documents/users/$(resource.data.ownerId)/wardrobes/$(resource.data.wardrobeId)/clothes/$(clothId)).data);
      
      // Allow partial update for wear tracking (requires updatedAt)
      allow update: if isAuthenticated() && 
                      (!('ownerId' in resource.data) || resource.data.ownerId == request.auth.uid) &&
                      (!('ownerId' in request.resource.data) || request.resource.data.ownerId == request.auth.uid) &&
                      request.resource.data.likesCount == resource.data.likesCount &&
                      request.resource.data.commentsCount == resource.data.commentsCount &&
                      'updatedAt' in request.resource.data &&
                      (!('wornAt' in request.resource.data) || request.resource.data.wornAt is timestamp);
      // Allow full cloth update (all fields required)
      allow update: if isAuthenticated() && 
                      (!('ownerId' in resource.data) || resource.data.ownerId == request.auth.uid) &&
                      (!('ownerId' in request.resource.data) || request.resource.data.ownerId == request.auth.uid) &&
                      request.resource.data.likesCount == resource.data.likesCount &&
                      request.resource.data.commentsCount == resource.data.commentsCount &&
                      isValidCloth(request.resource.data);
      allow delete: if isAuthenticated() && 
                      resource.data.ownerId == request.auth.uid;
    }
    
    // ============================================
    // WARDROBES COLLECTION (Top-level for queries)
    // ============================================
    // Note: Wardrobes are stored in users/{userId}/wardrobes/{wardrobeId}
    // This top-level collection is for querying across all wardrobes (if needed)
    // Also allows writes to sync with subcollection
    match /wardrobes/{wardrobeId} {
      allow read: if isAuthenticated();
      // Allow write if user owns the wardrobe (ownerId matches authenticated user)
      allow create: if isAuthenticated() && 
                      request.resource.data.ownerId == request.auth.uid &&
                      isValidWardrobe(request.resource.data);
      allow update: if isAuthenticated() && 
                      resource.data.ownerId == request.auth.uid &&
                      request.resource.data.ownerId == request.auth.uid &&
                      isValidWardrobe(request.resource.data);
      allow delete: if isAuthenticated() && 
                      resource.data.ownerId == request.auth.uid;
    }
    
    // ============================================
    // CHATS COLLECTION (Top-level for queries)
    // ============================================
    // Note: Chats are stored in users/{userId}/chats/{chatId}
    // This top-level collection is for querying across all chats (if needed)
    match /chats/{chatId} {
      allow read: if isAuthenticated() && 
                     request.auth.uid in resource.data.participants;
      allow write: if false; // Write only through subcollection path
    }
  }
}
